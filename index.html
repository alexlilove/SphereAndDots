<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <title>Интерактивная прозрачная сфера</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: rgba(20,26,48,.7);
      --txt: #e7eaf6;
    }
    html, body { height: 100%; margin: 0; }
    body { background: var(--bg); color: var(--txt); overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif; }
    canvas { display: block; }
    .banner { position: absolute; left: 50%; top: 10px; transform: translateX(-50%); z-index: 10; pointer-events: auto; }
    .banner .card { background: var(--panel); border: 1px solid rgba(255,255,255,.12); border-radius: 12px; width: 250px; padding: 10px 14px; font-size: 13px; line-height: 1.35; box-shadow: 0 10px 30px rgba(0,0,0,.25); position: relative; }
    .banner .close-btn { position: absolute; top: 11px; right: 8px; cursor: pointer; font-weight: bold; color: #fff; }
    .label { font-weight: 700; font-size: 12px; color: #fff; text-shadow: 0 0 6px rgba(0,0,0,.7); user-select: none; white-space: nowrap; }
  </style>
</head>
<body>
  <div class="banner"><div class="card">
    <div class="close-btn">×</div>
    • Вращайте сферу и меняйте её размер.<br>
    • Добавляйте точки нажатием и удаляйте удержанием.<br>
    • Выберите 2 точки — через них пройдет большая окружность.
  </div></div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.161.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    const R = 1;
    camera.position.set(0, 0, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0';
    labelRenderer.domElement.style.left = '0';
    labelRenderer.domElement.style.pointerEvents = 'none';
    document.body.appendChild(labelRenderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = false;

    const sphereGeo = new THREE.SphereGeometry(R, 64, 64);
    const sphereMat = new THREE.MeshPhongMaterial({ color: 0x3a8bff, transparent: true, opacity: 0.28, side: THREE.DoubleSide });
    const sphere = new THREE.Mesh(sphereGeo, sphereMat);
    scene.add(sphere);

    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 5, 6);
    scene.add(dir);

    const COLOR_RED = 0xff3333;
    const COLOR_BLUE = 0x3399ff;
    const COLOR_GREEN = 0x33ff33;
    const COLOR_RED_DIM = 0xdd1111;
    const COLOR_BLUE_DIM = 0x224466;
    const COLOR_GREEN_DIM = 0x225522;

    const points = [];
    let nextChar = 'A'.charCodeAt(0);
    let selectedForCircle = [];
    let greatCircle = null;

    function makeLabel(text){
      const el = document.createElement('div');
      el.className = 'label';
      el.textContent = text;
      return el;
    }

    function addPointAt(pos, forcedText=null, forcedColor=null){
      const onSurface = pos.length() > R * 0.5;
      const p = onSurface ? pos.clone().normalize().multiplyScalar(R) : pos.clone();
      const geom = new THREE.SphereGeometry(0.025, 16, 16);
      const mat = new THREE.MeshBasicMaterial({ color: forcedColor ?? COLOR_RED });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.copy(p);
      scene.add(mesh);

      const labelText = forcedText ?? String.fromCharCode(nextChar++);
      const labelEl = makeLabel(labelText);
      const labelObj = new CSS2DObject(labelEl);
      labelObj.position.set(0.06, 0.06, 0);
      mesh.add(labelObj);

      const entry = { mesh, labelObj, labelEl, labelText, isSelected:false, baseColor: forcedColor ?? COLOR_RED };
      points.push(entry);
      return entry;
    }

    function removePointAtIndex(idx){
      if (idx < 0 || idx >= points.length) return;
      const wasSelected = selectedForCircle.includes(idx);
      scene.remove(points[idx].mesh);
      points[idx].mesh.remove(points[idx].labelObj);
      points.splice(idx,1);
      if (wasSelected){
        selectedForCircle = selectedForCircle.filter(i => i !== idx).map(i => i > idx ? i-1 : i);
      } else {
        selectedForCircle = selectedForCircle.map(i => i > idx ? i-1 : i);
      }
      if (greatCircle) { scene.remove(greatCircle); greatCircle = null; }
      if (selectedForCircle.length === 2) drawGreatCircle(selectedForCircle[0], selectedForCircle[1]);
    }

    function setSelected(idx, val){
      const p = points[idx];
      if (!p) return;
      p.isSelected = !!val;
      refreshPointColor(idx);
    }

    function refreshPointColor(idx){
      const p = points[idx];
      if (!p) return;
      const base = p.isSelected ? COLOR_BLUE : p.baseColor;
      const camDir = camera.position.clone().normalize();
      const normal = p.mesh.getWorldPosition(new THREE.Vector3()).normalize();
      const visible = normal.dot(camDir) > 0;
      let dimColor;
      if (p.isSelected) dimColor = COLOR_BLUE_DIM;
      else if (p.baseColor === COLOR_BLUE) dimColor = COLOR_BLUE_DIM;
      else if (p.baseColor === COLOR_GREEN) dimColor = COLOR_GREEN_DIM;
      else dimColor = COLOR_RED_DIM;
      const final = visible ? base : dimColor;
      p.mesh.material.color.set(final);
      p.labelEl.style.color = visible ? '#ffffff' : '#8a8f9f';
    }

    function refreshAllColors(){
      for (let i=0;i<points.length;i++) refreshPointColor(i);
    }

    function drawGreatCircle(i1, i2){
      if (greatCircle) { scene.remove(greatCircle); greatCircle = null; }
      const a = points[i1]?.mesh.position.clone().normalize();
      const b = points[i2]?.mesh.position.clone().normalize();
      if (!a || !b) return;
      const n = new THREE.Vector3().crossVectors(a,b);
      if (n.lengthSq() < 1e-8) return;
      n.normalize();
      const u = a.clone();
      const v = new THREE.Vector3().crossVectors(n,u).normalize();
      const seg = 256; const arr = new Array(seg).fill(0).map((_,i)=>{
        const t = i/seg * Math.PI*2;
        return u.clone().multiplyScalar(Math.cos(t)).add(v.clone().multiplyScalar(Math.sin(t))).multiplyScalar(R);
      });
      const geom = new THREE.BufferGeometry().setFromPoints(arr);
      greatCircle = new THREE.LineLoop(geom, new THREE.LineBasicMaterial({ color: 0x00ff88 }));
      scene.add(greatCircle);
    }

    addPointAt(new THREE.Vector3(0, 0, 0), '', COLOR_GREEN);

    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();
    let isDown = false, moved = false, startX=0, startY=0;
    const DRAG_PX = 6;
    let downHitPointIndex = -1;
    let downHitSphere = false;
    let holdTimer = null, holdFired = false, lastPointerType = 'mouse';

    function setNDCFromEvent(e){
      const rect = renderer.domElement.getBoundingClientRect();
      const x = (('clientX' in e) ? e.clientX : e.touches?.[0]?.clientX) ?? 0;
      const y = (('clientY' in e) ? e.clientY : e.touches?.[0]?.clientY) ?? 0;
      ndc.x = ((x - rect.left) / rect.width) * 2 - 1;
      ndc.y = -((y - rect.top) / rect.height) * 2 + 1;
      return { x, y };
    }

    function pickPoint(){
      raycaster.setFromCamera(ndc, camera);
      const objs = points.map(p=>p.mesh);
      const hit = raycaster.intersectObjects(objs, false);
      return hit.length ? points.findIndex(p=>p.mesh===hit[0].object) : -1;
    }
    function pickSphere(){
      raycaster.setFromCamera(ndc, camera);
      const hit = raycaster.intersectObject(sphere, false);
      return hit.length ? hit[0].point.clone() : null;
    }

    function onPointerDown(e){
      lastPointerType = e.pointerType || (e.touches? 'touch' : 'mouse');
      isDown = true; moved = false; holdFired = false;
      const p = setNDCFromEvent(e); startX = p.x; startY = p.y;
      downHitPointIndex = pickPoint();
      downHitSphere = downHitPointIndex === -1 && !!pickSphere();
      if (lastPointerType === 'touch' && downHitPointIndex !== -1){
        holdTimer = setTimeout(() => {
          holdFired = true;
          removePointAtIndex(downHitPointIndex);
          downHitPointIndex = -1;
        }, 700);
      }
    }

    function onPointerMove(e){
      if (!isDown) return;
      const p = setNDCFromEvent(e);
      if (!moved && Math.hypot(p.x-startX, p.y-startY) > DRAG_PX){
        moved = true;
        if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
      }
    }

    function onPointerUp(e){
      if (!isDown) return;
      isDown = false;
      if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
      if (holdFired) { holdFired = false; return; }
      setNDCFromEvent(e);
      if (!moved){
        if (downHitPointIndex !== -1){
          const idx = downHitPointIndex;
          const already = selectedForCircle.includes(idx);
          setSelected(idx, !already);
          if (already){
            selectedForCircle = selectedForCircle.filter(i=>i!==idx);
          } else {
            selectedForCircle.push(idx);
            if (selectedForCircle.length > 2) {
              const first = selectedForCircle.shift();
              setSelected(first,false);
            }
          }
          if (selectedForCircle.length === 2){
            drawGreatCircle(selectedForCircle[0], selectedForCircle[1]);
          }
        } else if (downHitSphere){
          const hit = pickSphere();
          if (hit){ addPointAt(hit); }
        }
      }
      downHitPointIndex = -1; downHitSphere = false; moved = false;
    }

    const el = renderer.domElement;
    el.addEventListener('pointerdown', onPointerDown, { passive: true });
    el.addEventListener('pointermove', onPointerMove, { passive: true });
    el.addEventListener('pointerup', onPointerUp, { passive: true });
    el.addEventListener('pointercancel', onPointerUp, { passive: true });

    function onResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      refreshAllColors();
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
    }
    animate();

    document.querySelector('.close-btn').addEventListener('click', () => {
      document.querySelector('.banner').style.display = 'none';
    });
  </script>
</body>
</html>
