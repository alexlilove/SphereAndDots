<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>–î–∏–∞–≥—Ä–∞–º–º–∞ –í–æ—Ä–æ–Ω–æ–≥–æ</title>
<style>
  html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; background: #fff; }
  canvas { display: block; touch-action: none; }

  /* –í–µ—Ä—Ö–Ω—è—è –ø–ª–∞—à–∫–∞-–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è */
  #banner {
    position: absolute;
    top: 70px; left: 30px; right: 35px; /* –æ—Å—Ç–∞–≤–∏–º –º–µ—Å—Ç–æ –ø–æ–¥ ‚Ü©Ô∏è –∏ üîÑ —Å–ø—Ä–∞–≤–∞ */
    background: rgba(255,255,255,0.9);
    border-radius: 10px;
    box-shadow: 0 4px 18px rgba(0,0,0,0.12);
    padding: 10px 40px 10px 12px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, Helvetica, sans-serif;
    font-size: 14px;
    line-height: 1.35;
    user-select: none;
  }
  #banner .close {
    position: absolute;
    top: 6px; right: 8px;
    font-size: 18px; cursor: pointer;
    padding: 2px 6px; border-radius: 6px;
  }
  #banner .close:hover { background: rgba(0,0,0,0.06); }

  /* –ë–ª–æ–∫ —Å ‚Ü©Ô∏è –∏ üîÑ */
  #controls {
    position: absolute;
    top: 10px; right: 10px;
    display: flex; gap: 10px; font-size: 24px; user-select: none;
  }
  .btn {
    cursor: pointer; background: rgba(255,255,255,0.9);
    border-radius: 8px; padding: 4px 8px; box-shadow: 0 4px 18px rgba(0,0,0,0.12);
  }

  /* –ö–Ω–æ–ø–∫–∞ –ø–∞–ª–∏—Ç—Ä—ã (üé®) —Å–Ω–∏–∑—É —Å–ª–µ–≤–∞ */
  #paletteBtn {
    position: absolute; left: 12px; bottom: 12px; user-select: none;
    font-size: 22px; line-height: 1; cursor: pointer;
    background: rgba(255,255,255,0.95);
    border-radius: 12px; padding: 8px 10px;
    box-shadow: 0 4px 18px rgba(0,0,0,0.12);
  }

  /* –ü–∞–Ω–µ–ª—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞–ª–∏—Ç—Ä—ã */
  #palettePanel {
    position: absolute; left: 15px; bottom: 70px; width: 340px;
    background: rgba(255,255,255,0.98);
    border-radius: 12px; padding: 12px; box-shadow: 0 12px 28px rgba(0,0,0,0.18);
    opacity: 95%;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, Helvetica, sans-serif;
    display: none;
  }
  #palettePanel.open { display: block; }
  #palettePanel h3 {
    margin: 0 0 10px; font-size: 16px; font-weight: 600;
  }
  .colors { display: grid; grid-template-columns: 1fr auto; gap: 8px 10px; align-items: center; }
  .color-row { display: contents; }
  .color-row input[type="color"] { width: 100%; height: 36px; border: none; background: transparent; }
  .color-row button { cursor: pointer; background: transparent; border: none; font-size: 18px; }
  .hint { font-size: 12px; color: #555; margin-top: 6px; }
  .actions { display: flex; gap: 8px; margin-top: 10px; }
  .action-btn {
    cursor: pointer; background: #889; color: #fff; border: none; border-radius: 10px; padding: 8px 12px; font-size: 14px;
  }
  .secondary { background: #e9e9e9; color: #000; }
  .disabled { opacity: 0.6; pointer-events: none; }
</style>
</head>
<body>
  <canvas id="voronoi"></canvas>

  <div id="banner">
    –î–æ–±–∞–≤–ª—è–π—Ç–µ –∏ –ø–µ—Ä–µ–º–µ—â–∞–π—Ç–µ —Ç–æ—á–∫–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –¥–∏–∞–≥—Ä–∞–º–º—ã –í–æ—Ä–æ–Ω–æ–≥–æ. –£–¥–∞–ª—è–π—Ç–µ –¥–≤–æ–π–Ω—ã–º —Ç–∞–ø–æ–º, –º–∞—Å—à—Ç–∞–±–∏—Ä—É–π—Ç–µ –¥–≤—É–º—è –ø–∞–ª—å—Ü–∞–º–∏.
    <span class="close" id="bannerClose">√ó</span>
  </div>
  <div id="controls">
    <div class="btn" id="undo" title="–û—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥">‚Ü©Ô∏è</div>
    <div class="btn" id="restart" title="–†–µ—Å—Ç–∞—Ä—Ç">üîÑ</div>
  </div>

  <!-- –ö–Ω–æ–ø–∫–∞ –ø–∞–ª–∏—Ç—Ä—ã –∏ –ø–∞–Ω–µ–ª—å -->
  <div id="paletteBtn" title="–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –ø–∞–ª–∏—Ç—Ä—É">üé®</div>
  <div id="palettePanel" aria-hidden="true">
    <h3>–¶–≤–µ—Ç–∞ –¥–∏–∞–≥—Ä–∞–º–º—ã</h3>
    <div class="colors" id="colorsList"></div>
    <div class="hint">–ú–∏–Ω–∏–º—É–º 4 —Ü–≤–µ—Ç–∞</div>
    <div class="actions">
      <button class="action-btn secondary" id="addColor"> –î–æ–±–∞–≤–∏—Ç—å</button>
      <button class="action-btn" id="applyPalette">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
      <button class="action-btn secondary" id="closePalette">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>
  </div>

  <script src="https://unpkg.com/d3-delaunay@6"></script>
  <script>
  // =====================
  //  –ë–ê–ó–û–í–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï
  // =====================
  const canvas = document.getElementById('voronoi');
  const ctx = canvas.getContext('2d');

  // –ü–∞–ª–∏—Ç—Ä–∞: –∑–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ localStorage –ª–∏–±–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–µ—Ñ–æ–ª—Ç
  const defaultPalette = ["#397DFE", "#E4275C", "#FBA367", "#0ECF54", "#8012D5"]; // 5 –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
  let palette = loadPalette();

  let points = [];                // –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –ú–ò–†–û–í–´–• –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö (world)
  let history = [];

  // –ü–∞–Ω/–∑—É–º (–í–ê–ñ–ù–û: –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –î–û –ø–µ—Ä–≤–æ–≥–æ draw/resize)
  let scale = 1;                  // –º–∞—Å—à—Ç–∞–± (screen = world*scale + translate)
  let translate = {x:0, y:0};     // –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ

  // –ñ–µ—Å—Ç—ã/—É–∫–∞–∑–∞—Ç–µ–ª–∏
  const pointers = new Map();     // pointerId -> {x,y}
  let gesture = null;             // –¥–∞–Ω–Ω—ã–µ pinch-–∂–µ—Å—Ç–∞
  let draggingPointIndex = null;  // –∏–Ω–¥–µ–∫—Å —Ç–æ—á–∫–∏, –µ—Å–ª–∏ —Ç–∞—â–∏–º –æ–¥–Ω—É —Ç–æ—á–∫—É
  let dragOffset = {x:0, y:0};    // world-—Å–º–µ—â–µ–Ω–∏–µ –æ—Ç –∫—É—Ä—Å–æ—Ä–∞ –¥–æ —Ü–µ–Ω—Ç—Ä–∞ —Ç–æ—á–∫–∏ –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
  let dragStarted = false;

  // –¢–∞–ø/–¥–∞–±–ª-—Ç–∞–ø
  let lastTapTime = 0;
  let lastTapPos = {x:0, y:0}; // –≤ SCREEN –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
  const DOUBLE_TAP_MS = 300;
  const TAP_MOVE_TOL = 8;      // px

  // –ü–ª–∞—à–∫–∞
  document.getElementById('bannerClose').addEventListener('click', () => {
    const b = document.getElementById('banner');
    if(!b) return; b.style.display = 'none';
  });

  // =====================
  //  –ü–ê–õ–ò–¢–†–ê ‚Äî UI
  // =====================
  const paletteBtn = document.getElementById('paletteBtn');
  const palettePanel = document.getElementById('palettePanel');
  const colorsList = document.getElementById('colorsList');
  const addColorBtn = document.getElementById('addColor');
  const applyPaletteBtn = document.getElementById('applyPalette');
  const closePaletteBtn = document.getElementById('closePalette');

  const MIN_COLORS = 4;

  function loadPalette(){
    try {
      const raw = localStorage.getItem('voronoi_palette');
      if(raw){
        const arr = JSON.parse(raw);
        if(Array.isArray(arr) && arr.length >= MIN_COLORS && arr.every(isColor)){ return arr; }
      }
    } catch(_){}
    return defaultPalette.slice();
  }

  function savePalette(){
    try { localStorage.setItem('voronoi_palette', JSON.stringify(palette)); } catch(_){ }
  }

  function isColor(v){ return typeof v === 'string' && /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v); }

  function openPalette(){
    renderPaletteRows();
    palettePanel.classList.add('open');
    palettePanel.setAttribute('aria-hidden','false');
  }
  function closePalette(){
    palettePanel.classList.remove('open');
    palettePanel.setAttribute('aria-hidden','true');
  }

  function renderPaletteRows(){
    colorsList.innerHTML = '';
    palette.forEach((hex, i) => {
      const row = document.createElement('div');
      row.className = 'color-row';
      const input = document.createElement('input');
      input.type = 'color';
      input.value = hex;
      input.addEventListener('input', () => { palette[i] = input.value; });

      const rm = document.createElement('button');
      rm.title = '–£–¥–∞–ª–∏—Ç—å —Ü–≤–µ—Ç';
      rm.textContent = '‚úñ';
      rm.onclick = () => {
        if(palette.length > MIN_COLORS){
          palette.splice(i,1);
          renderPaletteRows();
          validatePaletteButtons();
        }
      };
      if(palette.length <= MIN_COLORS){ rm.classList.add('disabled'); }

      colorsList.appendChild(row);
      row.appendChild(input);
      row.appendChild(rm);
    });
    validatePaletteButtons();
  }

  function validatePaletteButtons(){
    // –ü—Ä–∏–º–µ–Ω–∏—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ >= MIN_COLORS –∏ –≤—Å–µ –≤–∞–ª–∏–¥–Ω—ã–µ —Ü–≤–µ—Ç–∞
    const ok = palette.length >= MIN_COLORS && palette.every(isColor);
    applyPaletteBtn.classList.toggle('disabled', !ok);
  }

  paletteBtn.addEventListener('click', () => {
    if(palettePanel.classList.contains('open')) closePalette(); else openPalette();
  });
  closePaletteBtn.addEventListener('click', closePalette);
  addColorBtn.addEventListener('click', () => {
    // –î–æ–±–∞–≤–ª—è–µ–º –±–ª–∏–∂–∞–π—à–∏–π –∫ –ø–æ—Å–ª–µ–¥–Ω–µ–º—É —Ü–≤–µ—Ç—É (–ª–∏–±–æ —á—ë—Ä–Ω—ã–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
    const base = palette[palette.length-1] || '#000000';
    palette.push(base);
    renderPaletteRows();
  });
  applyPaletteBtn.addEventListener('click', () => {
    if(applyPaletteBtn.classList.contains('disabled')) return;
    savePalette();
    drawVoronoi();
    closePalette();
  });

  // –ö–ª–∏–∫ –≤–Ω–µ –ø–∞–Ω–µ–ª–∏ ‚Äî –∑–∞–∫—Ä—ã—Ç—å
  document.addEventListener('pointerdown', (e) => {
    if(!palettePanel.classList.contains('open')) return;
    const within = palettePanel.contains(e.target) || paletteBtn.contains(e.target);
    if(!within) closePalette();
  }, {passive:true});

  // =====================
  //  –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–û–ï
  // =====================
  function saveHistory(){ history.push(JSON.parse(JSON.stringify(points))); }

  function undo(){ if(history.length){ points = history.pop(); drawVoronoi(); } }
  function restart(){ points = []; history = []; drawVoronoi(); }
  document.getElementById('undo').onclick = undo;
  document.getElementById('restart').onclick = restart;

  // ===== –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω—ã–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è =====
  function screenToWorld(x, y){
    return { x: (x - translate.x) / scale, y: (y - translate.y) / scale };
  }
  function worldToScreen(x, y){
    return { x: x*scale + translate.x, y: y*scale + translate.y };
  }

  // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω–¥–µ–∫—Å –±–ª–∏–∂–∞–π—à–µ–π —Ç–æ—á–∫–∏ –≤ —Ä–∞–¥–∏—É—Å–µ Rpx —ç–∫—Ä–∞–Ω–∞
  function findPointScreenRadius(sx, sy, rPx = 10){
    const r2 = (rPx/scale)*(rPx/scale);   // —Ä–∞–¥–∏—É—Å –≤ world-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
    const w = screenToWorld(sx, sy);
    for(let i=0;i<points.length;i++){
      const dx = points[i][0] - w.x; const dy = points[i][1] - w.y;
      if(dx*dx + dy*dy <= r2) return i;
    }
    return null;
  }

  // =====================
  //  –°–õ–£–ß–ê–ô–ù–ê–Ø –ò –†–ê–í–ù–û–ú–ï–†–ù–ê–Ø –í–´–ë–û–†–ö–ê
  // =====================
  function randInt(n){ return Math.floor(Math.random() * n); }
  function choiceUniform(arr){ return arr[randInt(arr.length)]; }
  function shuffleInPlace(arr){
    for(let i = arr.length - 1; i > 0; i--){
      const j = randInt(i + 1);
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // =====================
  //  –†–ê–í–ù–û–í–ï–†–û–Ø–¢–ù–ê–Ø –†–ê–°–ö–†–ê–°–ö–ê –ë–ï–ó –°–û–í–ü–ê–î–ï–ù–ò–ô –°–û–°–ï–î–ï–ô
  // =====================
  function buildNeighborSets(delaunay, n){
    const neigh = Array.from({length:n}, () => new Set());
    for(let i=0;i<n;i++){
      // d3-delaunay –∏–Ω–æ–≥–¥–∞ –º–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å ¬´—Å—Ç—Ä–∞–Ω–Ω—ã–µ¬ª –∏–Ω–¥–µ–∫—Å—ã –ø—Ä–∏ —Å–æ–≤–ø–∞–¥–∞—é—â–∏—Ö —Ç–æ—á–∫–∞—Ö.
      // –ü–æ—ç—Ç–æ–º—É —Ñ–∏–ª—å—Ç—Ä—É–µ–º –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ: j –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ü–µ–ª—ã–º –≤ [0, n-1], –Ω–µ —Ä–∞–≤–Ω—ã–º i.
      for(const jRaw of delaunay.neighbors(i)){
        const j = (typeof jRaw === 'number') ? jRaw : -1;
        if(Number.isInteger(j) && j >= 0 && j < n && j !== i){
          // –∫ —ç—Ç–æ–º—É –º–æ–º–µ–Ω—Ç—É neigh[i] –∏ neigh[j] –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ —Å—É—â–µ—Å—Ç–≤—É—é—Ç
          neigh[i].add(j);
          neigh[j].add(i);
        }
      }
    }
    return neigh;
  }

  // –í—ã–±–∏—Ä–∞–µ–º –≤–µ—Ä—à–∏–Ω—É –ø–æ DSATUR: –º–∞–∫—Å. –Ω–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç—å, –∑–∞—Ç–µ–º –º–∞–∫—Å. —Å—Ç–µ–ø–µ–Ω—å, –∑–∞—Ç–µ–º —Å–ª—É—á–∞–π–Ω–æ
  function nextVertexDSATUR(neigh, colors){
    let bestSat = -1, bestDeg = -1;
    const ties = [];
    for(let v=0; v<neigh.length; v++){
      if(colors[v] !== undefined) continue;
      const used = new Set();
      for(const u of neigh[v]){ const cu = colors[u]; if(cu !== undefined) used.add(cu); }
      const sat = used.size;
      const deg = neigh[v].size;
      if(sat > bestSat || (sat === bestSat && deg > bestDeg)){
        bestSat = sat; bestDeg = deg; ties.length = 0; ties.push(v);
      } else if(sat === bestSat && deg === bestDeg){
        ties.push(v);
      }
    }
    return ties.length ? ties[randInt(ties.length)] : -1;
  }

  function availableColorsFor(v, neigh, colors, palette){
    const used = new Set();
    for(const u of neigh[v]){ const cu = colors[u]; if(cu !== undefined) used.add(cu); }
    return palette.filter(c => !used.has(c));
  }

  function isProperColoring(colors, neigh){
    for(let i=0;i<neigh.length;i++){
      for(const j of neigh[i]){
        if(i < j && colors[i] !== undefined && colors[j] !== undefined && colors[i] === colors[j]){
          return false;
        }
      }
    }
    return true;
  }

  function colorGraphUniform(neigh, palette){
    const n = neigh.length;
    const colors = Array(n);

    function backtrack(coloredCount){
      if(coloredCount === n) return true;
      const v = nextVertexDSATUR(neigh, colors);
      if(v === -1) return false;
      const avail = availableColorsFor(v, neigh, colors, palette).slice();
      if(avail.length === 0) return false;
      shuffleInPlace(avail); // —Ä–∞–≤–Ω–æ–≤–µ—Ä–æ—è—Ç–Ω–æ –ø—Ä–æ–±—É–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ü–≤–µ—Ç–∞
      for(const c of avail){
        colors[v] = c;
        if(backtrack(coloredCount + 1)) return true;
        colors[v] = undefined;
      }
      return false;
    }

    // –ù–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ø—ã—Ç–æ–∫ (–Ω–∞ —Å–ª—É—á–∞–π ¬´–Ω–µ—É–¥–∞—á–Ω–æ–≥–æ¬ª —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞)
    for(let attempt=0; attempt<20; attempt++){
      for(let i=0;i<n;i++) colors[i] = undefined;
      if(backtrack(0) && isProperColoring(colors, neigh)){
        return colors.slice();
      }
    }

    // –ï—Å–ª–∏ –≤—Å—ë-—Ç–∞–∫–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å (–∫—Ä–∞–π–Ω–µ –º–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω–æ) ‚Äî –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –∂–∞–¥–Ω—ã–π + –ª–æ–∫–∞–ª—å–Ω–∞—è –ø–æ–ø—Ä–∞–≤–∫–∞
    // (–≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π –∑–∞ —Å—á—ë—Ç –ø–µ—Ä–µ–±–æ—Ä–∞ –ø–æ—Ä—è–¥–∫–∞ –≤–µ—Ä—à–∏–Ω)
    const order = Array.from({length:n}, (_,i)=>i).sort((a,b)=>neigh[b].size - neigh[a].size);
    for(const v of order){
      const avail = availableColorsFor(v, neigh, colors, palette);
      if(avail.length === 0){
        // –ø–µ—Ä–µ—Å–æ–±–µ—Ä—ë–º –ø–æ—Ä—è–¥–æ–∫ —Å–ª—É—á–∞–π–Ω–æ –∏ –Ω–∞—á–Ω—ë–º —Å–Ω–∞—á–∞–ª–∞
        shuffleInPlace(order);
        for(let i=0;i<n;i++) colors[i] = undefined;
        // –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏–º —Ü–∏–∫–ª
        for(const vv of order){
          const av = availableColorsFor(vv, neigh, colors, palette);
          if(av.length === 0){
            // –≤ –∫—Ä–∞–π–Ω–µ —Ä–µ–¥–∫–æ–º —Å–ª—É—á–∞–µ ‚Äî –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–¥–æ–ª–∂–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π –ø–µ—Ä–µ—Ç–∞—Å–æ–≤–∫–µ
            continue;
          }
          colors[vv] = choiceUniform(av);
        }
        break;
      }
      colors[v] = choiceUniform(avail);
    }
    // –ù–∞ –≤—ã—Ö–æ–¥–µ —É–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ —Ä–∞—Å–∫—Ä–∞—Å–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞; –µ—Å–ª–∏ –Ω–µ—Ç ‚Äî –ø–æ–ø—Ä–æ–±—É–µ–º –µ—â—ë –ø–∞—Ä—É —Ä–∞–∑
    for(let k=0;k<10 && !isProperColoring(colors, neigh); k++){
      for(let i=0;i<n;i++) colors[i] = undefined;
      shuffleInPlace(order);
      for(const v of order){
        const av = availableColorsFor(v, neigh, colors, palette);
        if(av.length) colors[v] = choiceUniform(av);
      }
    }
    return colors;
  }

  // =====================
  //  –†–ï–ù–î–ï–† –í–û–†–û–ù–û–ì–û
  // =====================
  function drawVoronoi(){
    const width = canvas.width, height = canvas.height;
    ctx.setTransform(1,0,0,1,0,0); // —Å–±—Ä–æ—Å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏
    ctx.clearRect(0,0,width,height);

    // –ø—Ä–∏–º–µ–Ω–∏–º —Ç–µ–∫—É—â—É—é —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é
    ctx.setTransform(scale, 0, 0, scale, translate.x, translate.y);

    if(points.length === 0) return;

    // –ì—Ä–∞–Ω–∏—Ü—ã –≤ world-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö (–≤–∏–¥–∏–º–∞—è –æ–±–ª–∞—Å—Ç—å)
    const minW = screenToWorld(0,0);
    const maxW = screenToWorld(width, height);

    const delaunay = d3.Delaunay.from(points);
    const vor = delaunay.voronoi([minW.x, minW.y, maxW.x, maxW.y]);

    // --- –†–∞–≤–Ω–æ–≤–µ—Ä–æ—è—Ç–Ω–∞—è —Ä–∞—Å–∫—Ä–∞—Å–∫–∞ –±–µ–∑ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π —Å–æ—Å–µ–¥–µ–π ---
    const neigh = buildNeighborSets(delaunay, points.length);
    const colorsArr = colorGraphUniform(neigh, palette);

    // –Ø—á–µ–π–∫–∏
    ctx.lineWidth = 1/scale; // —á—Ç–æ–±—ã —Ç–æ–ª—â–∏–Ω–∞ –±—ã–ª–∞ –≤–∏–∑—É–∞–ª—å–Ω–æ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π
    for(let i=0;i<points.length;i++){
      ctx.beginPath();
      vor.renderCell(i, ctx);
      ctx.fillStyle = colorsArr[i] || palette[i % palette.length] || '#ccc';
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.stroke();
    }

    // –¢–æ—á–∫–∏
    ctx.fillStyle = '#000';
    for(const [x,y] of points){
      ctx.beginPath();
      ctx.arc(x, y, 5/scale, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // =====================
  //  –†–ê–ó–ú–ï–† –ö–ê–ù–í–ê–°–ê
  // =====================
  function resize(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    drawVoronoi();
  }
  window.addEventListener('resize', resize, {passive:true});

  // =====================
  //  –°–û–ë–´–¢–ò–Ø –£–ö–ê–ó–ê–¢–ï–õ–ï–ô
  // =====================
  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, {x: e.clientX, y: e.clientY});

    if(pointers.size === 1){
      // –í–æ–∑–º–æ–∂–Ω–æ–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ —Ç–æ—á–∫–∏ –æ–¥–Ω–∏–º –ø–∞–ª—å—Ü–µ–º/–º—ã—à—å—é
      const idx = findPointScreenRadius(e.clientX, e.clientY, 12);
      if(idx !== null){
        draggingPointIndex = idx;
        const w = screenToWorld(e.clientX, e.clientY);
        dragOffset.x = points[idx][0] - w.x;
        dragOffset.y = points[idx][1] - w.y;
        dragStarted = false;
      } else {
        // –Ω–µ –Ω–∞—á–∏–Ω–∞–µ–º –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–¥–Ω–∏–º –ø–∞–ª—å—Ü–µ–º (–ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º)
        draggingPointIndex = null;
      }
    }

    if(pointers.size === 2){
      // –ù–∞—á–∞–ª–æ pinch-–ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏—è
      const [p1, p2] = Array.from(pointers.values());
      const mid0 = { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
      const dist0 = Math.hypot(p1.x - p2.x, p1.y - p2.y);
      const worldAtMid0 = screenToWorld(mid0.x, mid0.y);
      gesture = {
        type: 'pinch',
        start: { p1: {...p1}, p2: {...p2}, mid: mid0, dist: dist0 },
        worldAtMid0,
        scale0: scale,
        translate0: {...translate}
      };
      draggingPointIndex = null; // –ø—Ä–∏ –¥–≤—É—Ö –ø–∞–ª—å—Ü–∞—Ö –Ω–µ —Ç–∞—Å–∫–∞–µ–º —Ç–æ—á–∫—É
    }

    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener('pointermove', (e) => {
    if(!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, {x: e.clientX, y: e.clientY});

    if(draggingPointIndex !== null && pointers.size === 1){
      // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Ç–æ—á–∫–∏
      const w = screenToWorld(e.clientX, e.clientY);
      points[draggingPointIndex][0] = w.x + dragOffset.x;
      points[draggingPointIndex][1] = w.y + dragOffset.y;
      dragStarted = true;
      drawVoronoi();
    }

    if(pointers.size === 2 && gesture && gesture.type === 'pinch'){
      const [q1, q2] = Array.from(pointers.values());
      const mid = { x: (q1.x + q2.x)/2, y: (q1.y + q2.y)/2 };
      const dist = Math.hypot(q1.x - q2.x, q1.y - q2.y);
      // –Ω–æ–≤—ã–π –º–∞—Å—à—Ç–∞–±
      let newScale = gesture.scale0 * (dist / Math.max(gesture.start.dist, 0.0001));
      newScale = Math.max(0.0001, newScale); // –∑–∞—â–∏—Ç–∏–º—Å—è –æ—Ç –Ω—É–ª—è
      // —É–¥–µ—Ä–∂–∏–≤–∞—Ç—å world-—Ç–æ—á–∫—É –ø–æ–¥ –Ω–∞—á–∞–ª—å–Ω—ã–º mid
      translate.x = mid.x - gesture.worldAtMid0.x * newScale;
      translate.y = mid.y - gesture.worldAtMid0.y * newScale;
      scale = newScale;
      drawVoronoi();
    }

    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener('pointerup', (e) => {
    if(pointers.has(e.pointerId)) pointers.delete(e.pointerId);

    // –ó–∞–≤–µ—Ä—à–∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ —Ç–æ—á–∫–∏ ‚Äî –∑–∞–ø–∏—à–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
    if(draggingPointIndex !== null){
      if(dragStarted) saveHistory();
      draggingPointIndex = null; dragStarted = false;
    }

    // –ï—Å–ª–∏ –∂–µ—Å—Ç pinch –∑–∞–≤–µ—Ä—à—ë–Ω
    if(gesture && gesture.type === 'pinch' && pointers.size < 2){
      gesture = null;
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–∏–Ω–æ—á–Ω–æ–≥–æ/–¥–≤–æ–π–Ω–æ–≥–æ —Ç–∞–ø–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ—Å—Ç–∞–ª—Å—è 0 –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–∏–Ω—Ç–µ—Ä–æ–≤
    // –∏ —ç—Ç–æ –±—ã–ª –ù–ï –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ–º —Ç–æ—á–∫–∏ –∏ –ù–ï –ø–∏–Ω—á
    if(pointers.size === 0 && !gesture){
      const now = performance.now();
      const moved = Math.hypot(e.clientX - lastTapPos.x, e.clientY - lastTapPos.y);
      const isDouble = (now - lastTapTime) < DOUBLE_TAP_MS && moved < TAP_MOVE_TOL;

      const idx = findPointScreenRadius(e.clientX, e.clientY, 12);
      if(isDouble){
        if(idx !== null){ // –¥–≤–æ–π–Ω–æ–π —Ç–∞–ø –ø–æ —Ç–æ—á–∫–µ ‚Äî —É–¥–∞–ª–∏—Ç—å
          saveHistory();
          points.splice(idx, 1);
          drawVoronoi();
        }
        lastTapTime = 0; // —Å–±—Ä–æ—Å
      } else {
        // –æ—Ç–ª–æ–∂–∏–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∏, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞—Ç—å –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–º—É –¥–∞–±–ª-—Ç–∞–ø—É
        setTimeout(() => {
          // –î–æ–±–∞–≤–ª—è—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –¥–∞–±–ª-—Ç–∞–ø —Ç–∞–∫ –∏ –Ω–µ –ø—Ä–∏—à—ë–ª
          if((performance.now() - now) >= DOUBLE_TAP_MS){
            // –¥–æ–±–∞–≤–ª—è–µ–º —Ç–æ—á–∫—É, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –ø–æ–ø–∞–ª–∏ –ø–æ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π
            if(idx === null){
              saveHistory();
              const w = screenToWorld(e.clientX, e.clientY);
              points.push([w.x, w.y]);
              drawVoronoi();
            }
          }
        }, DOUBLE_TAP_MS + 5);
        lastTapTime = now; lastTapPos = {x: e.clientX, y: e.clientY};
      }
    }

    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener('pointercancel', (e) => {
    if(pointers.has(e.pointerId)) pointers.delete(e.pointerId);
    draggingPointIndex = null; dragStarted = false; gesture = null;
  }, {passive:true});

  // =====================
  //  SELF-TESTS (–ø—Ä–æ—Å—Ç—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏, –≤—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å)
  // =====================
  function runSelfTests(){
    const results = [];
    const log = (name, cond) => { results.push({name, pass: !!cond}); if(!cond) console.error('[TEST FAIL]', name); };

    // 1) –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç ‚Äî –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å
    const W = {x: 123.45, y: -67.89};
    const S = worldToScreen(W.x, W.y);
    const W2 = screenToWorld(S.x, S.y);
    log('screen<->world round-trip', Math.hypot(W.x-W2.x, W.y-W2.y) < 1e-6);

    // 2) –†–µ–Ω–¥–µ—Ä –±–µ–∑ —Ç–æ—á–µ–∫ (–Ω–µ –¥–æ–ª–∂–Ω–æ –ø–∞–¥–∞—Ç—å)
    try { drawVoronoi(); log('draw with 0 points', true); } catch(e){ log('draw with 0 points', false); }

    // 3) –†–µ–Ω–¥–µ—Ä —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ —Ç–æ—á–∫–∞–º–∏
    const backup = points.slice();
    try {
      points = [[0,0],[100,0],[50,80]];
      drawVoronoi();
      log('draw with 3 points', true);
      // 4) –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Ç–æ—á–∫–∏
      points[0][0] += 10; points[0][1] += 5; drawVoronoi();
      log('move point + redraw', true);
      // 5) –£–¥–∞–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∏
      points.splice(1,1); drawVoronoi();
      log('delete point + redraw', true);
    } catch(e){
      log('draw/move/delete flow', false);
    } finally {
      points = backup;
      drawVoronoi();
    }

    // 6) –ü—Ä–æ–≤–µ—Ä–∫–∞ buildNeighborSets –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç–∞—Ö (—Ä–∞–Ω—å—à–µ —Ç—É—Ç –º–æ–≥–ª–∞ –±—ã—Ç—å –æ—à–∏–±–∫–∞)
    try {
      const pts = [[0,0],[0,0],[50,50]]; // –¥—É–±–ª–∏–∫–∞—Ç—ã
      const del = d3.Delaunay.from(pts);
      const neigh = buildNeighborSets(del, pts.length);
      log('neighbors with duplicates ‚Äî no crash', Array.isArray(neigh) && neigh.length===pts.length);
    } catch(e){
      console.error(e);
      log('neighbors with duplicates ‚Äî no crash', false);
    }

    // 7) –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ —Ä–∞—Å–∫—Ä–∞—Å–∫–∏ –Ω–∞ —Å–ª—É—á–∞–π–Ω—ã—Ö —Ç–æ—á–∫–∞—Ö
    function checkRandom(n){
      const pts = Array.from({length:n}, ()=>[Math.random()*200-100, Math.random()*200-100]);
      const del = d3.Delaunay.from(pts);
      const neigh = buildNeighborSets(del, pts.length);
      const cols = colorGraphUniform(neigh, palette.slice(0, Math.max(MIN_COLORS, 4)));
      return isProperColoring(cols, neigh);
    }
    try {
      const okSmall = checkRandom(5) && checkRandom(8) && checkRandom(12);
      log('uniform coloring is proper (random sets)', okSmall);
    } catch(e){ log('uniform coloring is proper (random sets)', false); }

    const allPass = results.every(r=>r.pass);
    console.log('%cSelf-tests:', 'font-weight:bold', results, 'allPass=', allPass);
    return allPass;
  }

  // =====================
  //  –°–¢–ê–†–¢ –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø
  // =====================
  function start(){
    resize();           // —Ç–µ–ø–µ—Ä—å –±–µ–∑–æ–ø–∞—Å–Ω–æ: scale/translate —É–∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã
    runSelfTests();     // –ø—Ä–æ—Å—Ç—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤ –∫–æ–Ω—Å–æ–ª–∏
  }
  start();
  </script>
</body>
  </html>
